<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Mesh Visualizer</title>
    <style>
		body { margin: 0; }
		canvas { display: block; }
		#drop-zone {
			width: 100vw;
			height: 100vh;
			display: flex;
			justify-content: center;
			align-items: center;
			border: 2px dashed #aaa;
			color: #aaa;
			font-size: 1.5em;
			position: absolute;
			top: 0;
			left: 0;
			border-radius: 10px;
			cursor: pointer;
			z-index: 5;
			pointer-events: auto;
		}
		#drop-zone.small {
			width: 300px;
			height: 200px;
			position: fixed;
			bottom: 20px;
			right: 20px;
			border-radius: 10px;
			pointer-events: auto;
		}
		#drop-zone::before {
			content: 'Drop your STL file here or click to upload';
			font-size: 1.5em;
			color: #aaa;
		}
		#loading {
			display: none;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			font-size: 2em;
			color: #777;
		}
		#info-panel {
			position: fixed;
			top: 10px;
			right: 10px;
			width: 300px;
			padding: 20px;
			background-color: rgba(255, 255, 255, 0.9);
			border-radius: 10px;
			box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.2);
			font-family: Arial, sans-serif;
			z-index: 20;
		}
		#info-panel h2 {
			margin-top: 0;
			font-size: 1.2em;
		}
		#info-panel p {
			margin: 0.5em 0;
			font-size: 1em;
		}
		#view-cube {
			position: fixed;
			bottom: 20px;
			left: 20px;
			width: 100px;
			height: 100px;
			background-color: rgba(255, 255, 255, 0.9);
			border-radius: 10px;
			display: grid;
			grid-template-columns: repeat(3, 1fr);
			grid-template-rows: repeat(3, 1fr);
			box-shadow: 0px 0px 15px rgba(0, 0, 0, 0.2);
			font-family: Arial, sans-serif;
			z-index: 20;
		}
		.view-cube-face {
			display: flex;
			justify-content: center;
			align-items: center;
			border: 1px solid #ccc;
			cursor: pointer;
			user-select: none;
		}
		.view-cube-face:hover {
			background-color: #ddd;
		}
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
</head>
<body>
<div id="drop-zone"></div>
<div id="loading">Loading...</div>
<div id="info-panel" style="display: none;">
    <h2>Mesh Information</h2>
    <p id="info-centroid">Centroid: (0, 0, 0)</p>
    <p id="info-volume">Volume: 0</p>
    <p id="info-triangles">Number of Triangles: 0</p>
</div>
<div id="view-cube">
    <div class="view-cube-face" data-view="top">Top</div>
    <div class="view-cube-face" data-view="front">Front</div>
    <div class="view-cube-face" data-view="right">Right</div>
    <div class="view-cube-face" data-view="left">Left</div>
    <div class="view-cube-face" data-view="back">Back</div>
    <div class="view-cube-face" data-view="bottom">Bottom</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/STLLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
<script>
    class MeshHandler {
        constructor(scene, camera, renderer, controls) {
            this.scene = scene;
            this.camera = camera;
            this.renderer = renderer;
            this.controls = controls;
            this.loader = new THREE.STLLoader();
            this.mesh = null;
            this.centroid = new THREE.Vector3();
            this.volume = 0;
        }

        computeAccurateCentroid(geometry) {
            const centroid = new THREE.Vector3();
            const position = geometry.attributes.position;
            const numVertices = position.count;

            for (let i = 0; i < numVertices; i++) {
                centroid.add(new THREE.Vector3(position.getX(i), position.getY(i), position.getZ(i)));
            }

            centroid.divideScalar(numVertices);
            return centroid;
        }

        computeVolume(geometry) {
            let volume = 0;
            const position = geometry.attributes.position;

            for (let i = 0; i < position.count; i += 3) {
                const p1 = new THREE.Vector3(position.getX(i), position.getY(i), position.getZ(i));
                const p2 = new THREE.Vector3(position.getX(i + 1), position.getY(i + 1), position.getZ(i + 2));
                const p3 = new THREE.Vector3(position.getX(i + 2), position.getY(i + 2), position.getZ(i + 2));
                volume += p1.dot(p2.cross(p3)) / 6.0;
            }

            return Math.abs(volume);
        }

        loadMesh(arrayBuffer) {
            if (this.mesh) {
                this.scene.remove(this.mesh);
                if (this.centroidPoint) this.scene.remove(this.centroidPoint);
            }

            const geometry = this.loader.parse(arrayBuffer);
            const material = new THREE.MeshPhongMaterial({ color: 0x808080 }); // Gray color for the model
            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.scale.set(0.1, 0.1, 0.1); // Scale down the model if it's too large

            // Compute the centroid and volume of the mesh
            this.centroid = this.computeAccurateCentroid(geometry);
            this.volume = this.computeVolume(geometry);
            this.mesh.geometry.translate(-this.centroid.x, -this.centroid.y, -this.centroid.z); // Center the mesh

            this.scene.add(this.mesh);
            loadingText.style.display = 'none';
            infoPanel.style.display = 'block';
            dropZone.classList.add('small'); // Restrict drop zone to the bottom panel
            console.log("STL file successfully loaded and added to the scene.");

            // Set controls target to the centroid for orbiting around the center of the mesh
            this.controls.target.set(0, 0, 0);
            this.controls.update();

            // Add a point to indicate the centroid of the mesh
            const centroidGeometry = new THREE.SphereGeometry(0.05, 16, 16);
            const centroidMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            this.centroidPoint = new THREE.Mesh(centroidGeometry, centroidMaterial);
            this.centroidPoint.position.set(0, 0, 0);
            this.scene.add(this.centroidPoint);

            // Update information panel
            document.getElementById('info-centroid').innerText = `Centroid: (${this.centroid.x.toFixed(2)}, ${this.centroid.y.toFixed(2)}, ${this.centroid.z.toFixed(2)})`;
            document.getElementById('info-volume').innerText = `Volume: ${this.volume.toFixed(2)}`;
            document.getElementById('info-triangles').innerText = `Number of Triangles: ${(geometry.index ? geometry.index.count / 3 : geometry.attributes.position.count / 3)}`;
        }
    }

    // Set up the scene, camera, and renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Add light sources
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 5, 5).normalize();
    scene.add(directionalLight);

    const ambientLight = new THREE.AmbientLight(0x404040); // Soft light
    scene.add(ambientLight);

    // Add OrbitControls for better user interaction like CAD software
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // Smooth the control movements
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.maxPolarAngle = Math.PI * 2;

    const infoPanel = document.getElementById('info-panel');
    const loadingText = document.getElementById('loading');
    const dropZone = document.getElementById('drop-zone');

    const meshHandler = new MeshHandler(scene, camera, renderer, controls);

    // Handle file uploads via the drop zone
    dropZone.addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.stl';
        input.onchange = (event) => {
            const file = event.target.files[0];
            if (file) {
                loadingText.style.display = 'block';
                const reader = new FileReader();
                reader.onload = function (e) {
                    meshHandler.loadMesh(e.target.result);
                };
                reader.readAsArrayBuffer(file);
            }
        };
        input.click();
    });

    // Handle drag-and-drop uploads
    dropZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        dropZone.classList.add('active');
        dropZone.style.borderColor = '#777';
        dropZone.style.color = '#777';
    });

    dropZone.addEventListener('dragleave', (event) => {
        event.preventDefault();
        dropZone.classList.remove('active');
        dropZone.style.borderColor = '#aaa';
        dropZone.style.color = '#aaa';
    });

    dropZone.addEventListener('drop', (event) => {
        event.preventDefault();
        dropZone.classList.remove('active');
        loadingText.style.display = 'block';

        const file = event.dataTransfer.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function (e) {
                meshHandler.loadMesh(e.target.result);
            };
            reader.readAsArrayBuffer(file);
        }
    });

    // Set the camera position
    camera.position.set(0, 0, 10);

    // Handle view cube clicks
    document.querySelectorAll('.view-cube-face').forEach(face => {
        face.addEventListener('click', () => {
            const view = face.getAttribute('data-view');
            switch (view) {
                case 'top':
                    camera.position.set(0, 10, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'front':
                    camera.position.set(0, 0, 10);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'right':
                    camera.position.set(10, 0, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'left':
                    camera.position.set(-10, 0, 0);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'back':
                    camera.position.set(0, 0, -10);
                    camera.lookAt(0, 0, 0);
                    break;
                case 'bottom':
                    camera.position.set(0, -10, 0);
                    camera.lookAt(0, 0, 0);
                    break;
            }
            controls.update();
        });
    });

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();
</script>
</body>
</html>