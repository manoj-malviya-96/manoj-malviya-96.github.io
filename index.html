<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<script src="./common.js"></script>
<head>
    <meta charset="utf-8">
    <meta name="generator" content="quarto-1.4.545">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <script src="site_libs/quarto-nav/quarto-nav.js"></script>
    <script src="site_libs/quarto-nav/headroom.min.js"></script>
    <script src="site_libs/clipboard/clipboard.min.js"></script>
    <script src="site_libs/quarto-search/autocomplete.umd.js"></script>
    <script src="site_libs/quarto-search/fuse.min.js"></script>
    <script src="site_libs/quarto-search/quarto-search.js"></script>
    <meta name="quarto:offset" content="./">
    <link href="./images/logo.png" rel="icon" type="image/png">
    <script src="site_libs/quarto-listing/list.min.js"></script>
    <script src="site_libs/quarto-listing/quarto-listing.js"></script>
    <script src="site_libs/quarto-html/quarto.js"></script>
    <script src="site_libs/quarto-html/popper.min.js"></script>
    <script src="site_libs/quarto-html/tippy.umd.min.js"></script>
    <script src="site_libs/quarto-html/anchor.min.js"></script>
    <link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
    <link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet"
          id="quarto-text-highlighting-styles">
    <script src="site_libs/bootstrap/bootstrap.min.js"></script>
    <link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
    <link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
    <script id="quarto-search-options" type="application/json">{
        "location": "navbar",
        "copy-button": false,
        "collapse-after": 3,
        "panel-placement": "end",
        "type": "overlay",
        "limit": 50,
        "keyboard-shortcut": [
            "f",
            "/",
            "s"
        ],
        "show-item-context": false,
        "language": {
            "search-no-results-text": "No results",
            "search-matching-documents-text": "matching documents",
            "search-copy-link-title": "Copy link to search",
            "search-hide-matches-text": "Hide additional matches",
            "search-more-match-text": "more match in this document",
            "search-more-matches-text": "more matches in this document",
            "search-clear-button-title": "Clear",
            "search-text-placeholder": "",
            "search-detached-cancel-button-title": "Cancel",
            "search-submit-button-title": "Submit",
            "search-label": "Search"
        }
    }</script>
    <!-- Load the site's custom styles -->
<!--    <script>-->

<!--        window.document.addEventListener("DOMContentLoaded", function (_event) {-->
<!--            const listingTargetEl = window.document.querySelector('#listing-listing .list');-->
<!--            if (!listingTargetEl) {-->
<!--                // No listing discovered, do not attach.-->
<!--                return;-->
<!--            }-->
<!--            const options = {-->
<!--                valueNames: ['listing-image', 'listing-date', 'listing-title', 'listing-author', 'listing-reading-time', 'listing-description', 'listing-categories', {data: ['index']}, {data: ['categories']}, {data: ['listing-date-sort']}, {data: ['listing-file-modified-sort']}],-->
<!--                searchColumns: ["listing-title", "listing-author", "listing-date", "listing-image", "listing-description"],-->
<!--            };-->

<!--            window['quarto-listings'] = window['quarto-listings'] || {};-->
<!--            window['quarto-listings']['listing-listing'] = new List('listing-listing', options);-->

<!--            if (window['quarto-listing-loaded']) {-->
<!--                window['quarto-listing-loaded']();-->
<!--            }-->
<!--        });-->
<!--        window.addEventListener('hashchange', () => {-->
<!--            if (window['quarto-listing-loaded']) {-->
<!--                window['quarto-listing-loaded']();-->
<!--            }-->
<!--        })-->
<!--    </script>-->

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

    <script type="text/javascript">
        const typesetMath = (el) => {
            if (window.MathJax) {
                // MathJax Typeset
                window.MathJax.typeset([el]);
            } else if (window.katex) {
                // KaTeX Render
                var mathElements = el.getElementsByClassName("math");
                var macros = [];
                for (var i = 0; i < mathElements.length; i++) {
                    var texText = mathElements[i].firstChild;
                    if (mathElements[i].tagName === "SPAN") {
                        window.katex.render(texText.data, mathElements[i], {
                            displayMode: mathElements[i].classList.contains('display'),
                            throwOnError: false,
                            macros: macros,
                            fleqn: false
                        });
                    }
                }
            }
        }
        window.Quarto = {
            typesetMath
        };
    </script>
    <link rel="stylesheet" href="styles.css">
    <title>Manoj Malviya</title>
</head>

<!-- body -->
<body class="light-mode">

<!-- header -->
<div id="header-placeholder" style="display: none;"></div>
<script>
    // Function to initialize theme toggle after loading header
    function initializeThemeToggle() {
        const themeSwitch = document.getElementById('theme-switch');
        if (themeSwitch) {
            themeSwitch.addEventListener('change', function () {
                themeSwitch.checked ? document.body.classList.add('dark-mode') : document.body.classList.remove('dark-mode');
            });
        }
    }
    let headerPlaceholder = document.getElementById('header-placeholder');
    loadContent("./header.html", headerPlaceholder, initializeThemeToggle);
</script>

<!-- Overlay with Three Dot Loading Spinner -->
<div id="content-placeholder-overlay" style="display: none;">
    <div class="spinner-grow" role="status"></div>
</div>

<!-- main content -->
<div id="content-placeholder" style="display: none;"></div>
<script>
    function setActiveLink(element) {
        // Remove active class from all nav links
        document.querySelectorAll('.navbar-nav .nav-link').forEach(link => {
            link.classList.remove('active');
        });

        // Add active class to the clicked nav link
        element.classList.add('active');
    }
    function loadMainContent(page, event) {
        const contentPlaceholder = document.getElementById('content-placeholder');
        const contentPlaceholderOverlay = document.getElementById('content-placeholder-overlay');

        // Load content (existing logic for loading content)
        loadContentWithDelay(page, contentPlaceholder, contentPlaceholderOverlay);

        // Set the active link on click
        if (!!event && !!event.currentTarget) {
            event.preventDefault(); // Prevent default link behavior
            setActiveLink(event.currentTarget);
        }

        // Use MutationObserver to detect content change in contentPlaceholder
        const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
                    // Re-initialize scroll and active link logic
                    initializeScrollTracking();

                    // Disconnect observer after the content has loaded
                    observer.disconnect();
                }
            });
        });

        // Start observing the contentPlaceholder for changes
        observer.observe(contentPlaceholder, { childList: true });
    }

    // Function to initialize the scroll tracking
    function initializeScrollTracking() {
        const sections = document.querySelectorAll('main section'); // Select all sections within the dynamically loaded content
        const navLinks = document.querySelectorAll('#TOC .nav-link'); // Sidebar links

        // Helper function to remove 'active' class from all links
        const removeActiveClasses = () => {
            navLinks.forEach(link => link.classList.remove('active'));
        };

        // Function to add 'active' class to the corresponding link
        const addActiveClass = (id) => {
            removeActiveClasses();
            const activeLink = document.querySelector(`#TOC a[href="#${id}"]`);
            if (activeLink) {
                activeLink.classList.add('active');
            }
        };

        // Track scroll position and update the active link based on the visible section
        window.addEventListener('scroll', function() {
            let currentSection = '';
            const scrollPosition = window.scrollY + window.innerHeight / 2; // Get the scroll position relative to the viewport's center

            sections.forEach(section => {
                const sectionTop = section.offsetTop; // Get section's distance from the top of the document
                const sectionHeight = section.offsetHeight;
                const sectionId = section.getAttribute('id');

                // Adjust condition to check if section is in view, accounting for viewport height
                if (scrollPosition >= sectionTop && scrollPosition < sectionTop + sectionHeight) {
                    currentSection = sectionId;
                }
            });

            // Update active class based on the current section in view
            if (currentSection) {
                addActiveClass(currentSection);
            }
        });
    }
    // Add Event Listener for Loading tree-pages.
    document.addEventListener(pageEventHandlerName, function (event) {
        loadMainContent(event.detail.page, null);
    });
    loadMainContent('./home.html', event);
</script>

<script id="quarto-html-after-body" type="application/javascript">
    document.addEventListener("DOMContentLoaded", function (event) {
        // Function to check if an element is a code annotation
        const isCodeAnnotation = (el) => {
            for (const clz of el.classList) {
                if (clz.startsWith('code-annotation-')) {
                    return true;
                }
            }
            return false;
        }

        // Initialize clipboard.js for code copy buttons
        const clipboard = new window.ClipboardJS('.code-copy-button', {
            text: function (trigger) {
                const codeEl = trigger.previousElementSibling.cloneNode(true);
                for (const childEl of codeEl.children) {
                    if (isCodeAnnotation(childEl)) {
                        childEl.remove();
                    }
                }
                return codeEl.innerText;
            }
        });

        // Event listener for successful copy action
        clipboard.on('success', function (e) {
            const button = e.trigger;
            button.blur(); // don't keep focus
            button.classList.add('code-copy-button-checked'); // flash "checked"
            var currentTitle = button.getAttribute("title");
            button.setAttribute("title", "Copied!");
            let tooltip;
            if (window.bootstrap) {
                button.setAttribute("data-bs-toggle", "tooltip");
                button.setAttribute("data-bs-placement", "left");
                button.setAttribute("data-bs-title", "Copied!");
                tooltip = new bootstrap.Tooltip(button, {
                    trigger: "manual",
                    customClass: "code-copy-button-tooltip",
                    offset: [0, -8]
                });
                tooltip.show();
            }
            setTimeout(function () {
                if (tooltip) {
                    tooltip.hide();
                    button.removeAttribute("data-bs-title");
                    button.removeAttribute("data-bs-toggle");
                    button.removeAttribute("data-bs-placement");
                }
                button.setAttribute("title", currentTitle);
                button.classList.remove('code-copy-button-checked');
            }, 1000);
            e.clearSelection(); // clear code selection
        });

        // Function to initialize tippy.js tooltips
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
            const config = {
                allowHTML: true,
                maxWidth: 500,
                delay: 100,
                arrow: false,
                appendTo: function (el) {
                    return el.parentElement;
                },
                interactive: true,
                interactiveBorder: 10,
                theme: 'quarto',
                placement: 'bottom-start',
            };
            if (contentFn) {
                config.content = contentFn;
            }
            if (onTriggerFn) {
                config.onTrigger = onTriggerFn;
            }
            if (onUntriggerFn) {
                config.onUntrigger = onUntriggerFn;
            }
            window.tippy(el, config);
        }

        // Initialize tooltips for footnote references
        const noterefs = document.querySelectorAll('a[role="doc-noteref"]');
        for (var i = 0; i < noterefs.length; i++) {
            const ref = noterefs[i];
            tippyHover(ref, function () {
                let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
                try {
                    href = new URL(href).hash;
                } catch {
                }
                const id = href.replace(/^#\/?/, "");
                const note = document.getElementById(id);
                return note.innerHTML;
            });
        }

        // Initialize tooltips for cross-references
        const xrefs = document.querySelectorAll('a.quarto-xref');
        const processXRef = (id, note) => {
            const stripColumnClz = (el) => {
                el.classList.remove("page-full", "page-columns");
                if (el.children) {
                    for (const child of el.children) {
                        stripColumnClz(child);
                    }
                }
            }
            stripColumnClz(note)
            if (id === null || id.startsWith('sec-')) {
                const container = document.createElement("div");
                if (note.children && note.children.length > 2) {
                    container.appendChild(note.children[0].cloneNode(true));
                    for (let i = 1; i < note.children.length; i++) {
                        const child = note.children[i];
                        if (child.tagName === "P" && child.innerText === "") {
                            continue;
                        } else {
                            container.appendChild(child.cloneNode(true));
                            break;
                        }
                    }
                    if (window.Quarto?.typesetMath) {
                        window.Quarto.typesetMath(container);
                    }
                    return container.innerHTML
                } else {
                    if (window.Quarto?.typesetMath) {
                        window.Quarto.typesetMath(note);
                    }
                    return note.innerHTML;
                }
            } else {
                const anchorLink = note.querySelector('a.anchorjs-link');
                if (anchorLink) {
                    anchorLink.remove();
                }
                if (window.Quarto?.typesetMath) {
                    window.Quarto.typesetMath(note);
                }
                if (note.classList.contains("callout")) {
                    return note.outerHTML;
                } else {
                    return note.innerHTML;
                }
            }
        }

        // Initialize tooltips for cross-references
        for (var i = 0; i < xrefs.length; i++) {
            const xref = xrefs[i];
            tippyHover(xref, undefined, function (instance) {
                instance.disable();
                let url = xref.getAttribute('href');
                let hash = undefined;
                if (url.startsWith('#')) {
                    hash = url;
                } else {
                    try {
                        hash = new URL(url).hash;
                    } catch {
                    }
                }
                if (hash) {
                    const id = hash.replace(/^#\/?/, "");
                    const note = document.getElementById(id);
                    if (note !== null) {
                        try {
                            const html = processXRef(id, note.cloneNode(true));
                            instance.setContent(html);
                        } finally {
                            instance.enable();
                            instance.show();
                        }
                    } else {
                        fetch(url.split('#')[0])
                            .then(res => res.text())
                            .then(html => {
                                const parser = new DOMParser();
                                const htmlDoc = parser.parseFromString(html, "text/html");
                                const note = htmlDoc.getElementById(id);
                                if (note !== null) {
                                    const html = processXRef(id, note);
                                    instance.setContent(html);
                                }
                            }).finally(() => {
                            instance.enable();
                            instance.show();
                        });
                    }
                } else {
                    fetch(url)
                        .then(res => res.text())
                        .then(html => {
                            const parser = new DOMParser();
                            const htmlDoc = parser.parseFromString(html, "text/html");
                            const note = htmlDoc.querySelector('main.content');
                            if (note !== null) {
                                if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                                    note.children[0].remove();
                                }
                                const html = processXRef(null, note);
                                instance.setContent(html);
                            }
                        }).finally(() => {
                        instance.enable();
                        instance.show();
                    });
                }
            }, function (instance) {
            });
        }

        // Variables to store selected annotation element
        let selectedAnnoteEl;

        // Function to generate selector for annotation
        const selectorForAnnotation = (cell, annotation) => {
            let cellAttr = 'data-code-cell="' + cell + '"';
            let lineAttr = 'data-code-annotation="' + annotation + '"';
            const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
            return selector;
        }

        // Function to select code lines based on annotation
        const selectCodeLines = (annoteEl) => {
            const doc = document;
            const targetCell = annoteEl.getAttribute("data-target-cell");
            const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
            const annoteSpan = document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
            const lines = annoteSpan.getAttribute("data-code-lines").split(",");
            const lineIds = lines.map((line) => {
                return targetCell + "-" + line;
            })
            let top = null;
            let height = null;
            let parent = null;
            if (lineIds.length > 0) {
                const el = document.getElementById(lineIds[0]);
                top = el.offsetTop;
                height = el.offsetHeight;
                parent = el.parentElement.parentElement;
                if (lineIds.length > 1) {
                    const lastEl = document.getElementById(lineIds[lineIds.length - 1]);
                    const bottom = lastEl.offsetTop + lastEl.offsetHeight;
                    height = bottom - top;
                }
                if (top !== null && height !== null && parent !== null) {
                    let div = document.getElementById("code-annotation-line-highlight");
                    if (div === null) {
                        div = document.createElement("div");
                        div.setAttribute("id", "code-annotation-line-highlight");
                        div.style.position = 'absolute';
                        parent.appendChild(div);
                    }
                    div.style.top = top - 2 + "px";
                    div.style.height = height + 4 + "px";
                    div.style.left = 0;
                    let gutterDiv = document.getElementById("code-annotation-line-highlight-gutter");
                    if (gutterDiv === null) {
                        gutterDiv = document.createElement("div");
                        gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                        gutterDiv.style.position = 'absolute';
                        const codeCell = document.getElementById(targetCell);
                        const gutter = codeCell.querySelector('.code-annotation-gutter');
                        gutter.appendChild(gutterDiv);
                    }
                    gutterDiv.style.top = top - 2 + "px";
                    gutterDiv.style.height = height + 4 + "px";
                }
                selectedAnnoteEl = annoteEl;
            }
        };

        // Function to unselect code lines
        const unselectCodeLines = () => {
            const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
            elementsIds.forEach((elId) => {
                const div = document.getElementById(elId);
                if (div) {
                    div.remove();
                }
            });
            selectedAnnoteEl = undefined;
        };

        // Handle positioning of the toggle on window resize
        window.addEventListener(
            "resize",
            throttle(() => {
                elRect = undefined;
                if (selectedAnnoteEl) {
                    selectCodeLines(selectedAnnoteEl);
                }
            }, 10)
        );

        // Function to throttle events
        function throttle(fn, ms) {
            let throttle = false;
            let timer;
            return (...args) => {
                if (!throttle) {
                    fn.apply(this, args);
                    throttle = true;
                } else {
                    if (timer) clearTimeout(timer);
                    timer = setTimeout(() => {
                        fn.apply(this, args);
                        timer = throttle = false;
                    }, ms);
                }
            };
        }

        // Attach click handler to the DT elements
        const annoteDls = document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
            annoteDlNode.addEventListener('click', (event) => {
                const clickedEl = event.target;
                if (clickedEl !== selectedAnnoteEl) {
                    unselectCodeLines();
                    const activeEl = document.querySelector('dt[data-target-cell].code-annotation-active');
                    if (activeEl) {
                        activeEl.classList.remove('code-annotation-active');
                    }
                    selectCodeLines(clickedEl);
                    clickedEl.classList.add('code-annotation-active');
                } else {
                    unselectCodeLines();
                    clickedEl.classList.remove('code-annotation-active');
                }
            });
        }

        // Function to find citation elements
        const findCites = (el) => {
            const parentEl = el.parentElement;
            if (parentEl) {
                const cites = parentEl.dataset.cites;
                if (cites) {
                    return {
                        el,
                        cites: cites.split(' ')
                    };
                } else {
                    return findCites(el.parentElement)
                }
            } else {
                return undefined;
            }
        };

        // Initialize tooltips for bibliography references
        var bibliorefs = document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i = 0; i < bibliorefs.length; i++) {
            const ref = bibliorefs[i];
            const citeInfo = findCites(ref);
            if (citeInfo) {
                tippyHover(citeInfo.el, function () {
                    var popup = document.createElement('div');
                    citeInfo.cites.forEach(function (cite) {
                        var citeDiv = document.createElement('div');
                        citeDiv.classList.add('hanging-indent');
                        citeDiv.classList.add('csl-entry');
                        var biblioDiv = document.getElementById('ref-' + cite);
                        if (biblioDiv) {
                            citeDiv.innerHTML = biblioDiv.innerHTML;
                        }
                        popup.appendChild(citeDiv);
                    });
                    return popup.innerHTML;
                });
            }
        }
    });
</script>
</body>
</html>